options {
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(Compilador)

import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Stack;

public class Compilador {

    private ErrorHandler errorHandler;
    private TabelaDeSimbolos tabelaDeSimbolos = new TabelaDeSimbolos();
    private GeradorDeCodigo geradorDeCodigo = new GeradorDeCodigo();

    // Controle de tipos semânticos
    private Stack<Integer> pilhaTipos = new Stack<Integer>();
    // 1=num(int), 2=real, 3=text, 4=flag(bool)

    private int VP;
    private List<String> listaDeIdentificadoresDaLinha;
    private List<Integer> listaBasesDaLinha;
    private int categoriaAtual;
    private Stack<Integer> pilhaDeDesvios = new Stack<Integer>();
    private int baseDoUltimoVetor;
    private int tamanhoDoUltimoVetor;
    private boolean houveInitLinha;
    private int primeiroBaseInit;
    private int indiceCorrenteVetor;
    private Token indiceConstante = null;

    public List<Instrucao> getInstrucoes() {
        return geradorDeCodigo.getInstrucoes();
    }

    public Compilador(Reader stream, ErrorHandler handler) {
        this(stream);
        this.errorHandler = handler;
        this.tabelaDeSimbolos.setErrorHandler(handler);
    }

    public String getCodigoGerado() {
        if (errorHandler.hasErrors()) {
            return "--- ERROS ENCONTRADOS. CÓDIGO NÃO GERADO ---";
        }
        return geradorDeCodigo.getCodigoIntermediario();
    }

    public static void main(String args[]) throws TokenMgrError, FileNotFoundException, ParseException {
        try {
            if (args.length == 0) {
                System.err.println("Uso: java Compilador <arquivo-fonte>");
                return;
            }
            ErrorHandler consoleHandler = new ErrorHandler();
            Reader reader = new InputStreamReader(new FileInputStream(args[0]));
            Compilador parser = new Compilador(reader, consoleHandler);
            System.out.println("=== Iniciando análise léxica e sintática ===");

            parser.programa();

            if (consoleHandler.hasErrors()) {
                System.out.println("\n=== Erros encontrados: ===");
                for (String error : consoleHandler.getErrorMessages()) {
                    System.err.println("- " + error);
                }
            } else {
                System.out.println("\n=== Análise concluída com sucesso ===");
                System.out.println(parser.getCodigoGerado());
            }
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo não encontrado: " + e.getMessage());
        } catch (TokenMgrError e) {
            System.err.println("ERRO LÉXICO FATAL: " + e.getMessage());
        }
    }

    // --- MÉTODOS AUXILIARES DE SEMÂNTICA ---

    // Regra iii: Aritmética
    private void verificaAritmetica(String op, Token t) {
        if (pilhaTipos.size() < 2) return;
        int t2 = pilhaTipos.pop();
        int t1 = pilhaTipos.pop();

        // Verifica se são numéricos (1=num, 2=real)
        if ((t1 != 1 && t1 != 2) || (t2 != 1 && t2 != 2)) {
            errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
                "Operação aritmética '" + op + "' requer operandos numéricos (num ou real).");
            pilhaTipos.push(2); // Push real como fallback
            return;
        }

        // Divisão (/) sempre gera REAL (Regra iii)
        if (op.equals("/")) {
            pilhaTipos.push(2);
        }
        // Se algum for REAL, resultado é REAL
        else if (t1 == 2 || t2 == 2) {
            pilhaTipos.push(2);
        }
        // Caso contrário, INT op INT = INT
        else {
            pilhaTipos.push(1);
        }
    }

    // Regra iv: Relacional
    private void verificaRelacional(String op, Token t) {
        if (pilhaTipos.size() < 2) return;
        int t2 = pilhaTipos.pop();
        int t1 = pilhaTipos.pop();

        // Compatibilidade (Regra i aplicada a comparação)
        boolean compativel = (t1 == t2) ||
                             (t1 == 1 && t2 == 2) ||
                             (t1 == 2 && t2 == 1); // Int e Real são comparáveis

        if (!compativel) {
            errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
                "Tipos incompatíveis para comparação '" + op + "': " + getTipoPorCategoria(t1) + " e " + getTipoPorCategoria(t2));
        }

        pilhaTipos.push(4); // Resultado é sempre FLAG (bool)
    }

    // Regra v: Lógica
    private void verificaLogica(String op, Token t) {
        if (pilhaTipos.size() < 2) return;
        int t2 = pilhaTipos.pop();
        int t1 = pilhaTipos.pop();

        if (t1 != 4 || t2 != 4) {
            errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
                "Operador lógico '" + op + "' requer operandos lógicos (flag).");
        }
        pilhaTipos.push(4); // Resultado flag
    }

    private void verificaLogicaUnaria(Token t) {
        if (pilhaTipos.isEmpty()) return;
        int t1 = pilhaTipos.pop();
        if (t1 != 4) {
             errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Operador '!' requer operando lógico.");
        }
        pilhaTipos.push(4);
    }

    // Regra i: Atribuição
    private void verificaAtribuicao(int tipoVar, Token t) {
        if (pilhaTipos.isEmpty()) return;
        int tipoExp = pilhaTipos.pop();

        // Mesmo tipo: OK
        if (tipoVar == tipoExp) return;

        // Int atribuído a Real: OK (coerção)
        if (tipoVar == 2 && tipoExp == 1) return;

        // Caso contrário: Erro
        errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
            "Tipo incompatível na atribuição. Esperado: " + getTipoPorCategoria(tipoVar) + ", Encontrado: " + getTipoPorCategoria(tipoExp));
    }

    private String getTipoPorCategoria(int categoria) {
        switch (categoria) {
            case 1: return "num";
            case 2: return "real";
            case 3: return "text";
            case 4: return "flag";
            default: return "desconhecido";
        }
    }
}

PARSER_END(Compilador)

SKIP : { " " | "\t" | "\n" | "\r" }

SPECIAL_TOKEN : {
    < LINE_COMMENT: "//" (~["\n", "\r"])* > |
    < BLOCK_COMMENT: "/*" (~["*"] | "*" ~["/"])* "*/" >
}

TOKEN : {
    <BEGIN: "begin"> | <DEFINE: "define"> |
    <START: "start"> | <END: "end"> | <SET: "set"> |
    <READ: "read"> | <SHOW: "show"> | <IF: "if"> |
    <THEN: "then"> | <ELSE: "else"> |
    <LOOP: "loop"> | <WHILE: "while"> | <NUM: "num"> | <REAL: "real"> |
    <TEXT: "text"> |
    <FLAG: "flag"> | <TRUE: "true"> | <FALSE: "false">
}

TOKEN : {
    <CONST_REAL: <DIGITO>(<DIGITO>)?(<DIGITO>)?(<DIGITO>)? "." <DIGITO>(<DIGITO>)? > |
    <CONST_INT: <DIGITO>(<DIGITO>)?(<DIGITO>)? > |
    <CONST_LITERAL: "\"" (~["\"", "\n", "\r"])* "\"" | "'" (~["'", "\n", "\r"])* "'" > |
    <ERRO_STRING_NAO_FINALIZADA: "\"" (~["\"", "\n", "\r"])* | "'" (~["'", "\n", "\r"])* >
}

TOKEN : {
    < OP_REL_LTLT_EQ: "<<=" > | < OP_REL_GTGT_EQ: ">>=" > | < OP_REL_EQ: "==" > |
    < OP_REL_NEQ: "!=" > |
    < OP_REL_LTLT: "<<" > | < OP_REL_GTGT: ">>" > | < OP_ARIT_POW: "**" > |
    < OP_ARIT_DIVINT: "%%" > |
    < OP_ARIT_SUM: "+" > | < OP_ARIT_SUB: "-" > | < OP_ARIT_MUL: "*" > |
    < OP_ARIT_DIV: "/" > |
    < OP_ARIT_MOD: "%" > | < OP_LOGIC_AND: "&" > | < OP_LOGIC_OR: "|" > |
    < OP_LOGIC_NOT: "!" > |
    < ASSIGN: "=" > | < SEMICOLON: ";" > | < COMMA: "," > |
    < LPAREN: "(" > | < RPAREN: ")" > |
    < LBRACKET: "[" > | < RBRACKET: "]" > |
    < LBRACE: "{" > | < RBRACE: "}" > | < COLON: ":" > | <DOT: "." >
}

TOKEN : {
    <ERRO_REAL_FRACAO_LONGA: (<DIGITO>)+ "." <DIGITO><DIGITO><DIGITO>(<DIGITO>)* > |
    <ERRO_REAL_INTEIRO_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* "." (<DIGITO>)+ > |
    <ERRO_REAL_INCOMPLETO: (<DIGITO>)+ "." > |
    <ERRO_INT_LONGO: <DIGITO><DIGITO><DIGITO><DIGITO>(<DIGITO>)* >
}

TOKEN : {
    <ERRO_ID_INICIA_COM_DIGITO: (<DIGITO>)+ (<LETRA> | "_") ((<LETRA> | <DIGITO> | "_")*) > |
    <ERRO_ID_DIGITOS_CONSECUTIVOS: (<LETRA> | "_")(<LETRA> | <DIGITO> | "_")* <DIGITO> <DIGITO> (<LETRA> | <DIGITO> | "_")* > |
    <ERRO_ID_TERMINA_COM_DIGITO: (<LETRA> | "_") (<LETRA> | <DIGITO> | "_")* <DIGITO> >
}

TOKEN : {
    <IDENTIFIER: (<LETRA> | "_") ((<LETRA> | <DIGITO> | "_")*)> |
    <#LETRA: ["a"-"z", "A"-"Z"]> |
    <#DIGITO: ["0"-"9"]>
}

TOKEN : { <ERRO_LEXICO: ~[] > }

void programa() :
{}
{
    <BEGIN> identificador_de_programa() declaracao() <START> lista_de_comandos()
    { geradorDeCodigo.gerar("STP", "0"); }
    <END> <DOT>
}

void identificador_de_programa() :
{ Token t; }
{
    ( t = <IDENTIFIER> { tabelaDeSimbolos.inserirPrograma(t.image); } | {} )
}

void declaracao() :
{}
{
    (
      <DEFINE>
      {
          listaDeIdentificadoresDaLinha = new ArrayList<String>();
          listaBasesDaLinha = new ArrayList<Integer>();
          VP = 0;
          houveInitLinha = false;
          primeiroBaseInit = -1;
      }
      lista_de_declaracao()
    |
      {}
    )
}

void lista_de_declaracao() :
{}
{
    ( declaracao_de_variaveis() lista_de_declaracao_linha() )+
}

void lista_de_declaracao_linha() :
{}
{
    ( declaracao_de_variaveis() lista_de_declaracao_linha() | {} )
}

void declaracao_de_variaveis() :
{}
{
    try {
        lista_de_identificadores() <COLON> tipo() decl_do_vetor() <SEMICOLON>
        {
            // 1. ALOCAÇÃO
            String op;
            if (categoriaAtual == 1) op = "ALI";
            else if (categoriaAtual == 2) op = "ALR";
            else if (categoriaAtual == 3) op = "ALS";
            else op = "ALB";
            if (VP > 0) {
                geradorDeCodigo.gerar(op, String.valueOf(VP));
            }

            // 2. INICIALIZAÇÃO
            if (houveInitLinha) {
                String opLd;
                if (categoriaAtual == 1) opLd = "LDI";
                else if (categoriaAtual == 2) opLd = "LDR";
                else if (categoriaAtual == 3) opLd = "LDS";
                else opLd = "LDB";

                if (this.indiceConstante != null) {
                    String param = this.indiceConstante.image;
                    if (opLd.equals("LDB")) {
                        if (param.equalsIgnoreCase("true")) param = "1";
                        else if (param.equalsIgnoreCase("false")) param = "0";
                    }

                    // Valida atribuição inicial na declaração
                    int tipoConst = 0;
                    if (this.indiceConstante.kind == CONST_INT) tipoConst = 1;
                    else if (this.indiceConstante.kind == CONST_REAL) tipoConst = 2;
                    else if (this.indiceConstante.kind == CONST_LITERAL) tipoConst = 3;
                    else if (this.indiceConstante.kind == TRUE || this.indiceConstante.kind == FALSE) tipoConst = 4;

                    if (tipoConst != 0 && tipoConst != categoriaAtual) {
                         if (!(categoriaAtual == 2 && tipoConst == 1)) { // Permite int -> real
                             errorHandler.addError("Semântico", this.indiceConstante.beginLine, this.indiceConstante.beginColumn,
                                "Tipo incompatível na inicialização.");
                         }
                    }

                    geradorDeCodigo.gerar(opLd, param);
                }

                geradorDeCodigo.gerar("STR", String.valueOf(primeiroBaseInit));

                for (int k = 1; k < listaBasesDaLinha.size(); k++) {
                    geradorDeCodigo.gerar("LDV", String.valueOf(primeiroBaseInit));
                    geradorDeCodigo.gerar("STR", String.valueOf(listaBasesDaLinha.get(k)));
                }
            }
        }
    } catch (ParseException e) {
        if (errorHandler != null) {
            errorHandler.processParseException(e, "em declaração de variáveis");
        }
        Token t;
        while (true) {
            t = getToken(1);
            if (t.kind == EOF || t.kind == START || t.kind == SEMICOLON) {
                if (t.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    } finally {
        listaDeIdentificadoresDaLinha.clear();
        listaBasesDaLinha.clear();
        VP = 0;
        houveInitLinha = false;
        primeiroBaseInit = -1;
    }
}

void lista_de_identificadores() :
{ Token t; }
{
    t = <IDENTIFIER>
    {
        if (tabelaDeSimbolos.buscar(t.image) != null) {
            errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador '" + t.image + "' já declarado.");
        } else {
            listaDeIdentificadoresDaLinha.add(t.image);
        }
    }
    lista_de_identificadores_linha()
}

void lista_de_identificadores_linha() :
{ Token t; }
{
    (
        <COMMA> t = <IDENTIFIER>
        {
            if (tabelaDeSimbolos.buscar(t.image) != null) {
                errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador '" + t.image + "' já declarado.");
            } else {
                listaDeIdentificadoresDaLinha.add(t.image);
            }
        }
        lista_de_identificadores_linha()
    |
        {}
    )
}

void tipo() :
{}
{
    ( <NUM> { categoriaAtual = 1; }
    | <REAL> { categoriaAtual = 2; }
    | <TEXT> { categoriaAtual = 3; }
    | <FLAG> { categoriaAtual = 4; }
    )
}

void valor_imediato_decl() :
{ Token t; }
{
    ( t = <CONST_INT>   { this.indiceConstante = t; }
    | t = <CONST_REAL>  { this.indiceConstante = t; }
    | t = <CONST_LITERAL> { this.indiceConstante = t; }
    | t = <TRUE>        { this.indiceConstante = t; }
    | t = <FALSE>       { this.indiceConstante = t; }
    )
}

void decl_do_vetor() :
{}
{
    (
        <LBRACKET> constante_inteira() <RBRACKET>
        {
            int vtAtual = tabelaDeSimbolos.getVT();
            baseDoUltimoVetor = -1;
            for (String id : listaDeIdentificadoresDaLinha) {
                Simbolo s = tabelaDeSimbolos.inserir(id, categoriaAtual, tamanhoDoUltimoVetor);
                if (s != null) {
                    listaBasesDaLinha.add(s.getBase());
                    baseDoUltimoVetor = s.getBase();
                }
            }
            VP = (tamanhoDoUltimoVetor * listaDeIdentificadoresDaLinha.size());
        }
        inic_vetor()
    |
        ( <ASSIGN> valor_imediato_decl() { houveInitLinha = true; } | {} )
        {
            for (String id : listaDeIdentificadoresDaLinha) {
                Simbolo s = tabelaDeSimbolos.inserir(id, categoriaAtual, -1);
                if (s != null) {
                    listaBasesDaLinha.add(s.getBase());
                }
            }
            VP = listaDeIdentificadoresDaLinha.size();
            if (houveInitLinha) {
                primeiroBaseInit = listaBasesDaLinha.get(0);
            }
        }
    )
}

void constante_inteira() :
{ Token t; }
{
    t = <CONST_INT>
    {
        int valor = Integer.parseInt(t.image);
        if (valor <= 0) {
            errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Tamanho do vetor deve ser maior que 0.");
            tamanhoDoUltimoVetor = 1;
        } else {
            tamanhoDoUltimoVetor = valor;
        }
    }
}

void inic_vetor() :
{ indiceCorrenteVetor = 0; }
{
    (
        <ASSIGN> <LBRACE> lista_valores_vetor() <RBRACE>
        {
            if (indiceCorrenteVetor == 1) {
                int baseV = baseDoUltimoVetor;
                geradorDeCodigo.gerar("STR", String.valueOf(baseV));
                for (int j = 2; j <= tamanhoDoUltimoVetor; j++) {
                    geradorDeCodigo.gerar("LDV", String.valueOf(baseV));
                    geradorDeCodigo.gerar("STR", String.valueOf(baseV + (j-1)));
                }
            }
        }
    |
        {}
    )
}

void lista_valores_vetor() :
{}
{
    valor()
    {
        geradorDeCodigo.gerar("STR", String.valueOf(baseDoUltimoVetor + indiceCorrenteVetor));
        indiceCorrenteVetor++;

        if (!pilhaTipos.isEmpty()) {
            int tipoExp = pilhaTipos.pop();
            if (categoriaAtual != tipoExp && !(categoriaAtual == 2 && tipoExp == 1)) {
                 // Tratamento de erro simplificado para vetores
            }
        }
    }
    lista_valores_vetor_linha()
}

void lista_valores_vetor_linha() :
{}
{
    (
        <COMMA> valor()
        {
            geradorDeCodigo.gerar("STR", String.valueOf(baseDoUltimoVetor + indiceCorrenteVetor));
            indiceCorrenteVetor++;
            if (!pilhaTipos.isEmpty()) pilhaTipos.pop();
        }
        lista_valores_vetor_linha()
    |
        {}
    )
}

void valor() :
{ Token t; }
{
    ( t = <CONST_INT>   { geradorDeCodigo.gerar("LDI", t.image); pilhaTipos.push(1); }
    | t = <CONST_REAL>  { geradorDeCodigo.gerar("LDR", t.image); pilhaTipos.push(2); }
    | t = <CONST_LITERAL> { geradorDeCodigo.gerar("LDS", t.image); pilhaTipos.push(3); }
    | t = <TRUE>        { geradorDeCodigo.gerar("LDB", "1"); pilhaTipos.push(4); }
    | t = <FALSE>       { geradorDeCodigo.gerar("LDB", "0"); pilhaTipos.push(4); }
    )
}

void lista_de_comandos() :
{}
{
    (
        try {
            comando()
        } catch (ParseException e) {
            if (errorHandler != null) {
                 errorHandler.processParseException(e, "em comando");
            }
            Token t;
            while (true) {
                t = getToken(1);
                if (t.kind == EOF || t.kind == END ||
                    t.kind == SET || t.kind == READ ||
                    t.kind == SHOW || t.kind == IF || t.kind == LOOP)
                {
                    break;
                }
                getNextToken();
            }
        }
    )*
}

void comando() :
{}
{
    (
        atribuicao()
    |   entrada()
    |   saida()
    |   selecao()
    |   repeticao()
    )
}

void atribuicao() :
{
    Token t;
    Simbolo simboloLHS;
    boolean temIndiceLHS = false;
}
{
    try {
        <SET> t = <IDENTIFIER>
        {
            simboloLHS = tabelaDeSimbolos.buscar(t.image);
            if (simboloLHS == null) {
                errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador '" + t.image + "' não declarado.");
            }
            this.indiceConstante = null;
        }

        temIndiceLHS = indice(simboloLHS)

        <ASSIGN>

        expressao() // RHS (Pilha de Tipos: Topo é o tipo da expressão)

        {
            if (simboloLHS != null) {
                verificaAtribuicao(simboloLHS.getCategoria(), t);
            }
        }

        {
            if (simboloLHS != null) {
                if (simboloLHS.isVetor() && !temIndiceLHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador de vetor '" + simboloLHS.getLexema() + "' deve ser indexado.");
                } else if (!simboloLHS.isVetor() && temIndiceLHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador escalar '" + simboloLHS.getLexema() + "' não pode ser indexado.");
                }
            }
        }
        {
            if (simboloLHS != null) {
                if (temIndiceLHS) {
                    if (this.indiceConstante != null) {
                        int indice = Integer.parseInt(this.indiceConstante.image);
                        int endereco = simboloLHS.getBase() + (indice - 1);
                        geradorDeCodigo.gerar("STR", String.valueOf(endereco));
                    } else {
                        geradorDeCodigo.gerar("STX", "0");
                    }
                } else {
                    geradorDeCodigo.gerar("STR", String.valueOf(simboloLHS.getBase()));
                }
            }
        }
        <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
             errorHandler.processParseException(e, "em comando 'set'");
        }
        while (true) {
            t = getToken(1);
            if (t.kind == EOF || t.kind == SEMICOLON) {
                 if (t.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

void entrada() :
{
    Token t;
    Simbolo simboloLHS;
    boolean temIndiceLHS = false;
}
{
    try {
        <READ> <LPAREN> t = <IDENTIFIER>
        {
            simboloLHS = tabelaDeSimbolos.buscar(t.image);
            if (simboloLHS == null) {
                errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador '" + t.image + "' não declarado.");
            }
            this.indiceConstante = null;
        }

        temIndiceLHS = indice(simboloLHS)

        {
            if (simboloLHS != null) {
                if (simboloLHS.isVetor() && !temIndiceLHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador de vetor '" + simboloLHS.getLexema() + "' deve ser indexado.");
                } else if (!simboloLHS.isVetor() && temIndiceLHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador escalar '" + simboloLHS.getLexema() + "' não pode ser indexado.");
                }

                geradorDeCodigo.gerar("REA", String.valueOf(simboloLHS.getCategoria()));
                if (temIndiceLHS) {
                    if (this.indiceConstante != null) {
                        int indice = Integer.parseInt(this.indiceConstante.image);
                        int endereco = simboloLHS.getBase() + (indice - 1);
                        geradorDeCodigo.gerar("STR", String.valueOf(endereco));
                    } else {
                        geradorDeCodigo.gerar("STX", "0");
                    }
                } else {
                    geradorDeCodigo.gerar("STR", String.valueOf(simboloLHS.getBase()));
                }
            }
        }
        <RPAREN> <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
             errorHandler.processParseException(e, "em comando 'read'");
        }
        while (true) {
            t = getToken(1);
            if (t.kind == EOF || t.kind == SEMICOLON) {
                 if (t.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

boolean indice_entrada(Simbolo simboloLHS) :
{}
{
    (
        <LBRACKET> expressao()
        {
            if(simboloLHS != null) {
                geradorDeCodigo.gerar("LDI", String.valueOf(simboloLHS.getBase() - 1));
                geradorDeCodigo.gerar("ADD", "0");
            }
            if (!pilhaTipos.isEmpty()) pilhaTipos.pop();
        }
        <RBRACKET>
        { return true; }
    |
        {} { return false; }
    )
}

void saida() :
{}
{
    try {
        <SHOW> <LPAREN> lista_de_saida() <RPAREN> <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
             errorHandler.processParseException(e, "em comando 'show'");
        }
        Token t;
        while (true) {
            t = getToken(1);
            if (t.kind == EOF || t.kind == SEMICOLON) {
                 if (t.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

void lista_de_saida() :
{}
{
    item() ( <COMMA> item() )*
}

void item() :
{}
{
    (
        elemento()
        {
            geradorDeCodigo.gerar("WRT", "0");
            if (!pilhaTipos.isEmpty()) pilhaTipos.pop();
        }
    )
}

void selecao() :
{ int desvioJMF, desvioJMP; Token t; }
{
    try {
        t = <IF> expressao()
        {
            if (!pilhaTipos.isEmpty()) {
                int tipoExp = pilhaTipos.pop();
                if (tipoExp != 4) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
                        "Expressão do comando 'if' deve conter um operador relacional.");
                }
            }
            desvioJMF = geradorDeCodigo.gerar("JMF", "0");
            pilhaDeDesvios.push(desvioJMF);
        }
        <THEN> lista_de_comandos()
        senao()
        {
            int enderecoPendente = pilhaDeDesvios.pop();
            geradorDeCodigo.corrigir(enderecoPendente, String.valueOf(geradorDeCodigo.getProximoPonteiro()));
        }
        <END> <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
             errorHandler.processParseException(e, "em comando 'if'");
        }
        Token tk;
        while (true) {
            tk = getToken(1);
            if (tk.kind == EOF || tk.kind == SEMICOLON) {
                 if (tk.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

void senao() :
{}
{
    (
        <ELSE>
        {
            int desvioJMF = pilhaDeDesvios.pop();
            int desvioJMP = geradorDeCodigo.gerar("JMP", "0");
            geradorDeCodigo.corrigir(desvioJMF, String.valueOf(geradorDeCodigo.getProximoPonteiro()));
            pilhaDeDesvios.push(desvioJMP);
        }
        lista_de_comandos()
    |
        {}
    )
}

void repeticao() :
{ int inicioLoop, desvioJMF; Token t; }
{
    try {
        <LOOP> t = <WHILE>
        { inicioLoop = geradorDeCodigo.getProximoPonteiro();
        }

        expressao()

        {
            if (!pilhaTipos.isEmpty()) {
                int tipoExp = pilhaTipos.pop();
                if (tipoExp != 4) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn,
                        "Expressão do comando 'loop' deve ser lógica (flag).");
                }
            }
            desvioJMF = geradorDeCodigo.gerar("JMF", "0");
            pilhaDeDesvios.push(desvioJMF);
        }

        lista_de_comandos()

        {
            geradorDeCodigo.gerar("JMP", String.valueOf(inicioLoop));
            int enderecoJMF = pilhaDeDesvios.pop();
            geradorDeCodigo.corrigir(enderecoJMF, String.valueOf(geradorDeCodigo.getProximoPonteiro()));
        }
        <END> <SEMICOLON>
    } catch (ParseException e) {
        if (errorHandler != null) {
             errorHandler.processParseException(e, "em comando 'loop'");
        }
        Token tk;
        while (true) {
            tk = getToken(1);
            if (tk.kind == EOF || tk.kind == SEMICOLON) {
                 if (tk.kind == SEMICOLON) getNextToken();
                break;
            }
            getNextToken();
        }
    }
}

void expressao() : {} {
    expressao_aritmetica_ou_logica() expressao_linha()
}

void expressao_linha() : { Token t; } {
    ( t=<OP_REL_EQ> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("EQL", "0"); verificaRelacional("==", t); }
    | t=<OP_REL_NEQ> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("DIF", "0"); verificaRelacional("!=", t); }
    | t=<OP_REL_LTLT> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("SMR", "0"); verificaRelacional("<<", t); }
    | t=<OP_REL_GTGT> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("BGR", "0"); verificaRelacional(">>", t); }
    | t=<OP_REL_LTLT_EQ> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("SME", "0"); verificaRelacional("<<=", t); }
    | t=<OP_REL_GTGT_EQ> expressao_aritmetica_ou_logica() { geradorDeCodigo.gerar("BGE", "0"); verificaRelacional(">>=", t); }
    | {}
    )
}

void expressao_aritmetica_ou_logica() : {} {
    termo2()
    menor_prioridade()
}

void menor_prioridade() : { Token t; } {
    ( t=<OP_ARIT_SUM> termo2() { geradorDeCodigo.gerar("ADD", "0"); verificaAritmetica("+", t); } menor_prioridade()
    | t=<OP_ARIT_SUB> termo2() { geradorDeCodigo.gerar("SUB", "0"); verificaAritmetica("-", t); } menor_prioridade()
    | t=<OP_LOGIC_OR> termo2() { geradorDeCodigo.gerar("OR", "0"); verificaLogica("|", t); } menor_prioridade()
    | {}
    )
}

void termo2() : {} {
    termo1() media_prioridade()
}

void media_prioridade() : { Token t; } {
    ( t=<OP_ARIT_MUL> termo1() { geradorDeCodigo.gerar("MUL", "0"); verificaAritmetica("*", t); } media_prioridade()
    | t=<OP_ARIT_DIV> termo1() { geradorDeCodigo.gerar("DIV", "0"); verificaAritmetica("/", t); } media_prioridade()
    | t=<OP_ARIT_MOD> termo1() { geradorDeCodigo.gerar("MOD", "0"); verificaAritmetica("%", t); } media_prioridade()
    | t=<OP_ARIT_DIVINT> termo1() { geradorDeCodigo.gerar("REM", "0"); verificaAritmetica("%%", t); } media_prioridade()
    | t=<OP_LOGIC_AND> termo1() { geradorDeCodigo.gerar("AND", "0"); verificaLogica("&", t); } media_prioridade()
    | {}
    )
}

void termo1() : {} {
    elemento() maior_prioridade()
}

void maior_prioridade() : { Token t; } {
    ( t=<OP_ARIT_POW> elemento() { geradorDeCodigo.gerar("POW", "0"); verificaAritmetica("**", t); } maior_prioridade()
    | {}
    )
}

void elemento() :
{
    Token t;
    Simbolo simboloRHS;
    boolean temIndiceRHS = false;
}
{
    (
        t = <IDENTIFIER>
        {
            simboloRHS = tabelaDeSimbolos.buscar(t.image);
            if (simboloRHS == null) {
                errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador '" + t.image + "' não declarado.");
                pilhaTipos.push(1);
            } else {
                pilhaTipos.push(simboloRHS.getCategoria());
            }
            this.indiceConstante = null;
        }

        temIndiceRHS = indice(simboloRHS)

        {
             if (simboloRHS != null) {
                if (simboloRHS.isVetor() && !temIndiceRHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador de vetor '" + simboloRHS.getLexema() + "' deve ser indexado.");
                } else if (!simboloRHS.isVetor() && temIndiceRHS) {
                    errorHandler.addError("Semântico", t.beginLine, t.beginColumn, "Identificador escalar '" + simboloRHS.getLexema() + "' não pode ser indexado.");
                }

                if (temIndiceRHS) {
                    if (this.indiceConstante != null) {
                        int indice = Integer.parseInt(this.indiceConstante.image);
                        int endereco = simboloRHS.getBase() + (indice - 1);
                        geradorDeCodigo.gerar("LDV", String.valueOf(endereco));
                    } else {
                        geradorDeCodigo.gerar("LDX", "0");
                    }
                } else {
                    geradorDeCodigo.gerar("LDV", String.valueOf(simboloRHS.getBase()));
                }
            }
        }
    |
        t = <CONST_INT>
        {
            pilhaTipos.push(1);
            geradorDeCodigo.gerar("LDI", t.image);
        }
    |
        t = <CONST_REAL>
        {
            pilhaTipos.push(2);
            geradorDeCodigo.gerar("LDR", t.image);
        }
    |
        t = <CONST_LITERAL>
        {
            pilhaTipos.push(3);
            geradorDeCodigo.gerar("LDS", t.image);
        }
    |
        t = <TRUE>
        {
            pilhaTipos.push(4);
            geradorDeCodigo.gerar("LDB", "1");
        }
    |
        t = <FALSE>
        {
            pilhaTipos.push(4);
            geradorDeCodigo.gerar("LDB", "0");
        }
    |
        <LPAREN> expressao() <RPAREN>
    |
        t = <OP_LOGIC_NOT> <LPAREN> expressao() <RPAREN>
        {
            verificaLogicaUnaria(t);
            geradorDeCodigo.gerar("NOT", "0");
        }
    )
}

boolean indice(Simbolo simbolo) :
{ Token tok = null; }
{
    (
        <LBRACKET>
        (
            tok = <CONST_INT>
            {
                this.indiceConstante = tok;
            }
        |
            expressao()
            {
                this.indiceConstante = null;
                if (!pilhaTipos.isEmpty()) {
                    int tipoIndice = pilhaTipos.pop();
                    if (tipoIndice != 1) {
                        errorHandler.addError("Semântico", token.beginLine, token.beginColumn,
                            "Índice de vetor deve ser inteiro. Encontrado: " + getTipoPorCategoria(tipoIndice));
                    }
                }

                if(simbolo != null) {
                    geradorDeCodigo.gerar("LDI", String.valueOf(simbolo.getBase() - 1));
                    geradorDeCodigo.gerar("ADD", "0");
                }
            }
        )
        <RBRACKET>
        { return true; }
    |
        {} { this.indiceConstante = null; return false; }
    )
}